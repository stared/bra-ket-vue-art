---
title: "Logic operations, truth tables and matrices"
description: |
  Classical logics visualized with BraKetVue
author:
  - name: Piotr Migda≈Ç 
    url: https://p.migdal.pl
    affiliation: Quantum Flytrap
    affiliation_url: https://quantumgame.io
  - name: Klem Jankiewicz
    url: http://jankiewiczstudio.com/
    affiliation: Quantum Flytrap
    affiliation_url: https://quantumgame.io
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, results='asis', echo=FALSE, message=FALSE}
cat(
  "<script src='https://cdn.jsdelivr.net/npm/vue'></script>",
  "<script src='https://unpkg.com/quantum-tensors'></script>",
  "<script src='https://unpkg.com/bra-ket-vue'></script>"
)
```


Logic operations are basic building block of any more complicated computing.
THey are being used as base CPU instructions, and in high-level computing.


## Simple operations

We start with  0 and 1.

### NOT

The simplest operation is negation.

$$ \neg a $$
It takes one bit, and swaps it.

$$0 \mapsto 1 \hspace{1cm} 1 \mapsto 0$$
Or we can write the same thing using a matrix:

<div id='op-not'></div>

Note that in this matrix all values are either 1 or 0. 


### AND

$$ a \wedge b $$

$$00 \mapsto 0 \hspace{1cm} 01 \mapsto 0 \hspace{1cm} 10 \mapsto 0 \hspace{1cm} 11 \mapsto 1$$

<div id='op-and'></div>

### OR

$$ a \vee b $$

$$00 \mapsto 0 \hspace{1cm} 01 \mapsto 1 \hspace{1cm} 10 \mapsto 1 \hspace{1cm} 11 \mapsto 1$$

<div id='op-or'></div>

### XOR

$$a \oplus b $$


$$00 \mapsto 0 \hspace{1cm} 01 \mapsto 1 \hspace{1cm} 10 \mapsto 1 \hspace{1cm} 11 \mapsto 0$$

<div id='op-xor'></div>


### NAND

$$00 \mapsto 1 \hspace{1cm} 01 \mapsto 1 \hspace{1cm} 10 \mapsto 1 \hspace{1cm} 0 \mapsto 0$$

<div id='op-nand'></div>

### COPY

$$0 \mapsto 00 \hspace{1cm} 1 \mapsto 11$$

<div id='op-copy'></div>

### FIRST

$$00 \mapsto 0 \hspace{1cm} 01 \mapsto 0 \hspace{1cm} 10 \mapsto 1 \hspace{1cm} 1 \mapsto 0$$

<div id='op-first'></div>

### SECOND

$$00 \mapsto 0 \hspace{1cm} 01 \mapsto 1 \hspace{1cm} 10 \mapsto 0 \hspace{1cm} 1 \mapsto 0$$

<div id='op-second'></div>


## Reversibility

## Notes

This note is created with Learn more about using [Distill for R Markdown](https://rstudio.github.io/distill).

As of now, source code is at [github.com/stared/bra-ket-vue-art](https://github.com/stared/bra-ket-vue-art).

This particualr post inspired by [Kronecker Product In Circuits by Lei Mao ](https://leimao.github.io/blog/Kronecker-Product-In-Circuits/) and [Quantum Entanglement and Superdense Coding by Victory Omole](https://vtomole.com/blog/2018/03/03/sd).


```{js, results='asis', echo=FALSE, message=FALSE}
const { Elements, Operator, Dimension, Cx } = QuantumTensors;
const { ComplexLegend, MatrixViewer } = BraKetVue;

const opNot = Operator.fromSparseCoordNames([
  ['1', '0', Cx(1)],
  ['0', '1', Cx(1)],
], [Dimension.position(2, 'bit')]);

new Vue({
  el: "#op-not",
  template: "<matrix-viewer :operator-raw='opNot' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
    	opNot
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-and",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['0', '00', Cx(1)],
          ['0', '01', Cx(1)],
          ['0', '10', Cx(1)],
          ['1', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```


```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-or",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['0', '00', Cx(1)],
          ['1', '01', Cx(1)],
          ['1', '10', Cx(1)],
          ['1', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```


```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-xor",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['0', '00', Cx(1)],
          ['1', '01', Cx(1)],
          ['1', '10', Cx(1)],
          ['0', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-nand",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['1', '00', Cx(1)],
          ['1', '01', Cx(1)],
          ['1', '10', Cx(1)],
          ['0', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-copy",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['00', '0', Cx(1)],
          ['11', '1', Cx(1)],
        ],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit')])
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-first",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['0', '00', Cx(1)],
          ['0', '01', Cx(1)],
          ['1', '10', Cx(1)],
          ['1', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
new Vue({
  el: "#op-second",
  template: "<matrix-viewer :operator-raw='operator' :dark-mode='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
      operator: Operator.fromSparseCoordNames([
          ['0', '00', Cx(1)],
          ['1', '01', Cx(1)],
          ['0', '10', Cx(1)],
          ['1', '11', Cx(1)],
        ],
        [Dimension.position(2, 'bit')],
        [Dimension.position(2, 'bit'), Dimension.position(2, 'bit')])
		}
  }
})
```